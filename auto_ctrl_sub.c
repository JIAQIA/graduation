/********************************************************************************/
//◊‘∂Ø‘À––ƒ£øÈ
/********************************************************************************/ 
#include "math.h"
#include "string.h"
#include "stdlib.h"
#include "data_deal_def.h"
#include "auto_ctrl_def.h"

#include "key_code_def.h"
#include "inter_polate_def.h"

//#include "Basic_IO_cfg.h"

//-------º”π§¥˙¬Î∂Œ±‰¡ø∂®“Â---------------------------

#pragma DATA_SECTION(segment1, ".seg_bss")
typ_interp_segment segment1;
#pragma DATA_SECTION(segment2, ".seg_bss")
typ_interp_segment segment2;
#pragma DATA_SECTION(segment3, ".seg_bss")
typ_interp_segment segment3;
#pragma DATA_SECTION(segment4, ".seg_bss")
typ_interp_segment segment4;

typ_interp_segment  * interpl_segment_prev;
typ_interp_segment  * interpl_segment_curr;
typ_interp_segment  * interpl_segment_next;

typ_interp_segment  * interpl_segment_insert;

typ_interp_segment  * temp_segment_pointer;

//-------------------------------------------------------------------
/*****************************************************************/
//∫Ø ˝:  ∂Œ¥Ê¥¢Ω·ππ≥ı ºªØµ˜                                            
//»Îø⁄:                                                        
//∑µªÿ÷µ
//◊¢ Õ: 
//*****************************************************************
void interp_segment_init(void)
{
 interpl_segment_prev = &segment1;
 interpl_segment_curr = &segment2;
 interpl_segment_next = &segment3;
 interpl_segment_insert = &segment4;
 
 interpl_segment_prev->basecmd = PROGRAM_IDLE;

 interpl_segment_curr->basecmd = PROGRAM_IDLE;

 interpl_segment_next->basecmd = PROGRAM_IDLE;

 interpl_segment_insert->basecmd = PROGRAM_IDLE;

 interpl_segment_prev->interp_time.motion_stat = INP_MOTION_END;		   
 interpl_segment_prev->interp_time.motion_stat_next = INP_MOTION_END;

 interpl_segment_curr->interp_time.motion_stat = INP_MOTION_END;
 interpl_segment_curr->interp_time.motion_stat_next = INP_MOTION_END;
 interpl_segment_curr->interp_time.term_rem = 0;

 interpl_segment_next->interp_time.motion_stat = INP_MOTION_END;
 interpl_segment_next->interp_time.motion_stat_next = INP_MOTION_END;
 
 interpl_segment_insert->interp_time.motion_stat = INP_MOTION_END;
 interpl_segment_insert->interp_time.motion_stat_next = INP_MOTION_END;

}
/*****************************************************************/
//∫Ø ˝:  œﬂ–‘ÀŸ∂»–ﬁµ˜                                            
//»Îø⁄:  ±ª–ﬁµ˜≤ø∑÷µƒ¥Ê∑≈Œª÷√                                                              
//∑µªÿ÷µ:1-Ω¯––¡À–ﬁµ˜£¨0-Œ¥Ω¯–––ﬁµ˜                                                       
//◊¢ Õ:  Ω´–Ë“™–ﬁµ˜µƒ∂Œ∑÷Œ™¡Ω≤ø∑›£¨µ±«∞∂Œ±£¡Ù“ª≤ø∑÷£¨≤¢æ°øÏ◊™Œ™ºıÀŸ
//        £”‡≤ø∑÷ÃÓ»Îœ¬“ª∂Œ£¨◊º±∏∞¥’’–¬µƒÀŸ∂»–ﬁµ˜¡ø÷ÿ–¬πÊªÆ
/*****************************************************************/   
int linear_vel_override(typ_interp_segment * modify_pointer)
{
 int axis_idx;

 //≤ª «÷±œﬂ≤Â≤π£¨≤ªΩ¯–––ﬁµ˜
 if(interpl_segment_curr->basecmd != G_00)
   {
    mech_status.speed_scal_old = user_para.speed_scal;
    return(0);
   }

 // £”‡≤ø∑÷≥§∂»≤ªπª£¨≤ª–ﬁµ˜( override_echo_term ÷¡…Ÿ±ÿ–Î¥Û”⁄ºıÀŸµƒ÷‹∆⁄ ˝£´10)
 if(interpl_segment_curr->interp_time.term_rem <= user_para.override_echo_term)
   {
    mech_status.speed_scal_old = user_para.speed_scal;
    return(0);
   }

 //Ω¯»ÎºıÀŸΩ◊∂Œ≤ª–ﬁµ˜
 //if(interpl_segment_curr->interp_time[0].motion_stat_next == INP_MOTION_DEC)
 //  {
 //   speed_scal_old = speed_scal;
 //   return(0);
 //  }

 //º¥Ω´Ω¯»ÎºıÀŸΩ◊∂Œ≤ª–ﬁµ˜£®≤Ó10∏ˆ÷‹∆⁄£©
 if(interpl_segment_curr->interp_time.term_rem <= (interpl_segment_curr->interp_time.term_add + 10))
   {
    mech_status.speed_scal_old = user_para.speed_scal;
    return(0);
   }

 //÷ª”–‘⁄‘»ÀŸΩ◊∂Œ≤≈‘ –Ì–ﬁµ˜ 
 if(interpl_segment_curr->interp_time.motion_stat_next == INP_MOTION_UNI)
   { 	 
    mech_status.speed_scal_old = user_para.speed_scal;
    
    //µ±«∞∂Œ∏¥÷∆“ª∑›µΩ–ﬁ’˝∂Œ
    memcpy(modify_pointer, interpl_segment_curr, sizeof(typ_interp_segment));

    //5∏ˆ÷‹∆⁄∫Ûµ±«∞∂Œ±‰Œ™ºıÀŸ(£´5Œ™¡À»∑±£next∂Œ÷ÿ–¬πÊªÆµƒ ±º‰)
    interpl_segment_curr->interp_time.term_cmd = interpl_segment_curr->interp_time.term_run + 5;
    interpl_segment_curr->interp_time.term_rem = interpl_segment_curr->interp_time.term_add + 5;

    // £”‡≤ø∑÷”…œ¬“ª∂Œ∞¥’’–¬µƒÀŸ∂»÷ÿ–¬πÊªÆ
    modify_pointer->interp_time.term_cmd -= interpl_segment_curr->interp_time.term_cmd;
    
    //º∆À„œ¬“ª∂Œ÷–∏˜÷·£®…–Œ¥ÕÍ≥…µƒ£©‘À∂Ø∑÷¡ø£¨”–∑˚∫≈ ˝
    modify_pointer->dist = 0.0;
    for(axis_idx = 0; axis_idx < AXIS_SUM; axis_idx ++)
       {
        modify_pointer->axis_dist[axis_idx] =
	           modify_pointer->axis_vel[axis_idx] * modify_pointer->interp_time.term_cmd;
        modify_pointer->dist += modify_pointer->axis_dist[axis_idx]
                                * modify_pointer->axis_dist[axis_idx];
       } 
    modify_pointer->dist = sqrt(modify_pointer->dist);
    return(1);
   }
 return(0);
}
//***************************************************************************


//*********************************************************************************
//∫Ø ˝£∫¥”µ±«∞Œª÷√µΩ¥Ô÷∏∂®µƒŒª÷√
//»Îø⁄£∫position[]÷∏∂®“™µΩ¥ÔµƒŒª÷√£¨∏¯≥ˆø’º‰◊¯±Í
//      axis_num: ÷∏∂®–Ë“™‘À∂Øµƒ÷·∫≈£¨0001-X,0002-Y,0004-Z
//≥ˆø⁄£∫Ω´…œ ˆ‘À∂Ø◊™ªªŒ™¥˝≤Â≤π÷±œﬂ∂Œ∑≈»Îinterpl_segment_insert∂Œ÷–
//Àµ√˜£∫Ω´∑µªÿ‘›Õ£µ„µƒ‘À∂Ø–Œ≥…ø…÷¥––≥Ã–Ú∂Œº”‘ÿµΩnext∂Œ£¨≤¢‘⁄curr∂Œ≤Â»Î±ÿ“™µƒ—” ±
//*********************************************************************************
void appoint_position(float position[], unsigned int axis_num)
{
 int axis_idx;
 
 interpl_segment_insert->basecmd = G_00;
 interpl_segment_insert->vel = user_para.feed_vel;

 interpl_segment_insert->axis_dist[0] = 0.0; 
 interpl_segment_insert->axis_dist[1] = 0.0; 
 interpl_segment_insert->axis_dist[2] = 0.0; 

 if(axis_num & X_AXIS)
   {
	interpl_segment_insert->axis_dist[0] = position[0] - mech_status.curr_posi[0];
   }
 if(axis_num & Y_AXIS)
   {  
    interpl_segment_insert->axis_dist[1] = position[1] - mech_status.curr_posi[1];
   }
 if(axis_num & Z_AXIS)
   {  
    interpl_segment_insert->axis_dist[2] = position[2] - mech_status.curr_posi[2];
   }
   
 interpl_segment_insert->dist = 0.0;
 for(axis_idx = 0; axis_idx < AXIS_SUM; axis_idx ++)
    {
     interpl_segment_insert->dist += interpl_segment_insert->axis_dist[axis_idx]
                                * interpl_segment_insert->axis_dist[axis_idx];
    } 
 interpl_segment_insert->dist = sqrt(interpl_segment_insert->dist);
 ctrl_flag |= INSERT_SEG_FULL;
 ctrl_flag &= ~INSERT_SEG_READY; 
}
//*********************************************************************************
//∫Ø ˝£∫≤Â»Î‘À∂Ø—” ±µΩµ±«∞≤Â≤π∂Œ
//»Îø⁄£∫ ±º‰µ•ŒªŒ™ S
//≥ˆø⁄£∫
//Àµ√˜£∫‘⁄curr∂Œ≤Â»Î±ÿ“™µƒ—” ±
//*********************************************************************************
void insert_dwell_time(float dwell_time)
{
 interpl_segment_insert->basecmd = G_DWELL;
 interpl_segment_insert->dist = dwell_time;
 ctrl_flag |= INSERT_SEG_FULL;
 ctrl_flag &= ~INSERT_SEG_READY;
}
//----------------------------------------------------------------------------
/*void insert_segment(void)
{
 interpl_segment_next->label = 1;
 interpl_segment_next->basecmd = G_02; 
 interpl_segment_next->axis_dist[0] = 3.14/2;
 interpl_segment_next->axis_dist[1] = 0.1;
 interpl_segment_next->axis_dist[2] = 50.0;
 interpl_segment_next->dist = 3.14;
 interpl_segment_next->vel = 10;
}
*/
/*****************************************************************/
//∫Ø ˝£∫ºıÀŸÕ£≥µ
//»Îø⁄:
//∑µªÿ÷µ:
//◊¢ Õ:                                                        
/*****************************************************************/
void motion_abolish(void) 
{ 
 interpl_segment_curr->interp_time.term_cmd = interpl_segment_curr->interp_time.term_run;
 interpl_segment_curr->interp_time.term_rem = interpl_segment_curr->interp_time.term_add;
 interpl_segment_curr->interp_time.motion_stat_next = INP_MOTION_DEC;

 ctrl_flag &= (~BLEND_PERMIT); //Ω˚÷π≥Ã–Ú∂Œ◊™Ω”
}

/***********************************************************************/
// ∫Ø ˝: ≥Ã–Ú∂Œ‘§¥¶¿Ì (⁄÷˜∫Ø ˝—≠ª∑÷–µ˜”√)                                                   
// »Îø⁄:                                                               
// ∑µªÿ÷µ:                                                             
// ◊¢ Õ: ±æ∫Ø ˝Ω´seg_label÷∏∂®µƒ≥Ã–Ú∂ŒΩ¯––Ω‚ Õ£¨‘À∂Øøÿ÷∆¡øº”‘ÿµΩinterpl_segment_next∂Œ÷–
//       ø™πÿøÿ÷∆¡øº”‘ÿµΩplc_buffer÷–£¨≤¢Ω´‘À∂Ø—” ± ±º‰º”‘ÿµΩdwell_term
/***********************************************************************/
void code_seg_pre_treat(void) 
{
 if(ctrl_flag & INSERT_SEG_FULL)     //≤π≥‰≤Â»Î∂Œ¥Ê‘⁄£¨‘Ú”≈œ»∂‘∆‰Ω¯––πÊªÆ
   {
    if(!(ctrl_flag & INSERT_SEG_READY))		 //»ÙŒ¥πÊªÆÕÍ≥…
      {
       segment_plan(interpl_segment_insert);
       ctrl_flag |= INSERT_SEG_READY; 
      }
    return;  
   }
   
 if(ctrl_flag & NEXT_SEG_RENEW)    //’˝≥£≥Ã–Ú∂ŒπÊªÆ 
   { 
    if(segment_plan(interpl_segment_next)) //≥…π¶πÊªÆ
      {
       ctrl_flag &= (~NEXT_SEG_RENEW);
       switch(interpl_segment_next->basecmd)
         {
          case G_00:
          case G_01:
          case G_02:
          case G_03:
          case G_DWELL:
               ctrl_flag |= NEXT_SEG_READY;
               break;
          case G_04://pause
               ctrl_flag &= (~BLEND_PERMIT); 
               mech_status.stat = STA_PAUSING;
               ctrl_flag |= NEXT_SEG_EMPTY;       
               break;
    
          case PROGRAM_END: //finish
               ctrl_flag |= TASK_FINISH;     
               ctrl_flag &= ~BLEND_PERMIT;   
               break;
          default:;
         }//end of switch
       }  
    else mech_status.error = MECH_CODE_ERROR;
    
    return;
   }

 if(ctrl_flag & NEXT_SEG_EMPTY)              //≥Ã–Ú∂Œº”‘ÿµΩnext∂Œ
   {
    if(mech_code_load(interpl_segment_next))    //≥Ã–Ú¥˙¬Îº”‘ÿ≥…π¶ 
      {
       ctrl_flag &= (~NEXT_SEG_EMPTY);  
       ctrl_flag |= NEXT_SEG_RENEW; 
      }
    return;  
   }  
}

/*****************************************************************/
/* ∫Ø ˝:◊‘∂Ø‘À––÷–µƒ∞¥º¸¥¶¿Ì                                     */
/* »Îø⁄:                                                         */
/* ∑µªÿ÷µ:                                                       */
/* ◊¢ Õ:                                                         */
/*****************************************************************/ 
/*3.12∆¡±Œ
void auto_key_echo(unsigned int key_value) 
{
 switch(key_value)
   {
    case CMD_RUN:    //∆Ù∂Ø‘À––
         //ø™ º–¬µƒº”π§
         if(mech_status.stat == STA_FINISHED)
           {
            public_para_init(1);				//π´π≤±‰¡ø≥ı ºªØ
            //ctrl_flag = 0x0000;
            mech_status.stat = STA_READY;
           } 
         if(mech_status.stat == STA_READY)    
           {
            mech_flag &= ~SIMULATION;
            user_para.speed_scal = speed_scal;
            
            code_buf_init(); 					   //¥˙¬Î∂”¡–≥ı ºªØ
 	        interpl_segment_prev->basecmd = PROGRAM_IDLE;
		    interpl_segment_curr->label = 0;

            //≤Â»Îø™÷˜÷·—” ±
            insert_dwell_time(user_para.spindle_on_time);
            mech_status.spindle_rev = (int)(user_para.spindle_rev * user_para.spindle_scal/100);
            mech_flag |= SPINDLE_ON;
            //-----------------------------------------------------------
            ctrl_flag |= BEING_AUTO_RUN;
           	ctrl_flag &= ~TASK_FINISH;  
            ctrl_flag |= BLEND_PERMIT;   
		    ctrl_flag |= NEXT_SEG_EMPTY;   	   
            ctrl_flag &= ~CODE_BUF_READY;   
		    mech_status.stat = STA_WORKING;  //Ω¯»Îπ§◊˜◊¥Ã¨
     
            break;
           }         
         //--------------------------------------------------------------
         //¥”‘›Õ£÷–ª÷∏¥
         if(mech_status.stat == STA_PAUSED)
		   {
		    //»Áπ˚÷˜÷·Œ¥ø™£¨≤Â»Îø™÷˜÷·—” ±
            if(!(mech_flag & SPINDLE_ON) && !(mech_flag & SIMULATION))
              {
		       insert_dwell_time(user_para.spindle_on_time);
		       mech_status.spindle_rev = (int)(user_para.spindle_rev * user_para.spindle_scal/100);
               mech_flag |= SPINDLE_ON;
			  }
            //--------------------------------------------------- 
   		    ctrl_flag |= BLEND_PERMIT;         //blend_permit = ST_TRUE;
            mech_status.stat = STA_WORKING;    //Ω¯»Îπ§◊˜◊¥Ã¨
		   } 
		 //------------------------------------------------------  
         break;  
    case CMD_SIMU:
         public_para_init(1);
         mech_flag |= SIMULATION; 
         speed_scal = user_para.speed_scal;
         user_para.speed_scal = 500;
         
         code_buf_init();
 	     interpl_segment_prev->basecmd = PROGRAM_IDLE;
		 interpl_segment_curr->label = 0;
         //-----------------------------------------------------------
         ctrl_flag |= BEING_AUTO_RUN;
         ctrl_flag &= ~TASK_FINISH;  
         ctrl_flag |= BLEND_PERMIT;   
		 ctrl_flag |= NEXT_SEG_EMPTY;   	   
         ctrl_flag &= ~CODE_BUF_READY;   
		 mech_status.stat = STA_WORKING;  //Ω¯»Îπ§◊˜◊¥Ã¨
         break;           

    case CMD_PAUSE:        //‘À∂Ø‘›Õ£
         if(mech_status.stat == STA_WORKING)
           {
		    ctrl_flag &= (~BLEND_PERMIT); //blend_permit = ST_FAULSE;  // Ω˚÷π≥Ã–Ú∂Œ◊™Ω”£¨±æ∂ŒÕÍ≥…∫Û◊‘»ª‘›Õ£
    		mech_status.stat = STA_PAUSING;
           }    
         break;

    case CMD_STOP:         //Õ£÷π◊‘∂Ø‘À––
	     if(mech_status.stat == STA_WORKING)
           {
	        ctrl_flag &= (~BLEND_PERMIT); //blend_permit = ST_FAULSE;
		    mech_status.stat = STA_STOPPING;
		   }
         if(mech_status.stat == STA_PAUSED)  mech_status.stat = STA_STOPPED;
	     if(mech_status.stat == STA_FINISHED)  mech_status.stat = STA_STOPPED;
     	 break;

    case CMD_ESTOP:       //¡¢º¥Õ£≥µ
         if(interpl_segment_curr->interp_time.motion_stat > INP_MOTION_DEC)
           {
	        motion_abolish();
           }
         
         ctrl_flag &= (~BLEND_PERMIT); //Ω˚÷π≥Ã–Ú∂Œ◊™Ω” 
         mech_status.stat = STA_ESTOPPING;
         break;

    default: break;  
   }   //end of switch
} 
*/
//3.15÷ÿ–¥
void auto_ctrl()      //ºÏ≤‚µΩ°∞◊‘∂Ø°±º¸∞¥œ¬£¨Ω¯––“ªœ¬◊‘∂Ø‘À––«∞µƒ¥¶¿Ì
{
		public_para_init(1);				//π´π≤±‰¡ø≥ı ºªØ
		user_para.speed_scal = speed_scal;	   //…Ë÷√ÀŸ∂»
	    code_buf_init(); 					   //¥˙¬Î∂”¡–≥ı ºªØ
 	    interpl_segment_prev->basecmd = PROGRAM_IDLE;	 //º”‘ÿ≥Ã–Ú∂Œπ¶ƒ‹◊÷
		interpl_segment_curr->label = 0;				 //∂Œ±Í∫≈÷√¡„
		//≤Â»Îø™÷˜÷·—” ±
		insert_dwell_time(user_para.spindle_on_time);
		mech_status.spindle_rev = (int)(user_para.spindle_rev * user_para.spindle_scal/100); //ªÒµ√÷˜÷·◊™ÀŸ
		mech_flag |= SPINDLE_ON;
		//-----------------------------------------------------------
		ctrl_flag |= BEING_AUTO_RUN;
		ctrl_flag &= ~TASK_FINISH;  
		ctrl_flag |= BLEND_PERMIT;   
		ctrl_flag |= NEXT_SEG_EMPTY;   	   
		ctrl_flag &= ~CODE_BUF_READY;   
		mech_status.stat = STA_WORKING;  //Ω¯»Îπ§◊˜◊¥Ã¨
		/*
		//-------limit check-------------------------------
		if(stat_logic & LIMIT_IO_DEF) 
		{
			if(mech_status.stat == STA_WORKING)
			{
			key2_write(CMD_ESTOP); 
			mech_status.error = STATION_EXCEED;           
			} 
		} 
		//-------------------------------------------------           
          */  
        
} 

/*****************************************************************/
/* ∫Ø ˝:◊‘∂Ø‘À––≥Ã–Ú                                             */
/* »Îø⁄:                                                         */
/* ∑µªÿ÷µ:                                                       */
/* ◊¢ Õ:                                                         */
/*****************************************************************/ 
void auto_process(void)
{
 unsigned int axis_idx;

 //-------------≥Ã–Ú∂Œ◊‘∂Ø≤Â≤π¥¶¿Ì-----------------------------------
 segment_process(interpl_segment_curr);
 segment_process(interpl_segment_prev);
 
 //º∆À„“ª∏ˆ≤Â≤π÷‹∆⁄ƒ⁄∏˜÷· ‰≥ˆµƒ∫œ≥…Œª“∆¡ø
 for(axis_idx = 0; axis_idx < AXIS_SUM; axis_idx ++)
    {
     mech_status.dist_sum[axis_idx] = interpl_segment_curr->dist_out[axis_idx] 
                                    + interpl_segment_prev->dist_out[axis_idx];
    }   
 //-------------≥Ã–Ú∂Œ◊‘∂Ø◊™Ω”¥¶¿Ì----------------------------------- 
 
 if(ctrl_flag & BLEND_PERMIT)
   {
    //÷ª”–µ±«∞∂Œ £”‡÷‹∆⁄ ˝–°”⁄◊™Ω”÷‹∆⁄ ˝«“◊™Ω”‘ –Ì≤≈øº¬«◊™Ω”
    if((interpl_segment_curr->interp_time.term_rem <= user_para.blend_time)
        &&(interpl_segment_prev->basecmd==PROGRAM_IDLE)) 
      {
	   //------÷ª“™≤Â»Î∂Œ¥Ê‘⁄£¨æÕ≤ªΩ¯––’˝≥£◊™Ω”£¨“‘∑¿≥ˆ¥Ì----------------
       if(ctrl_flag & INSERT_SEG_FULL)  
         {        
          if(ctrl_flag & INSERT_SEG_READY) //÷ª”–∂ÓÕ‚∂œ◊º±∏∫√≤≈≤Â»Î∂ÓÕ‚µƒ∂Œ
            {
             temp_segment_pointer = interpl_segment_prev;	  //≥Ã–Ú∂Œ◊™Ω”		
             interpl_segment_prev = interpl_segment_curr;    
	         interpl_segment_curr = interpl_segment_insert;
             interpl_segment_insert = temp_segment_pointer;

             interpl_segment_insert->basecmd = PROGRAM_IDLE;
             ctrl_flag &= (~INSERT_SEG_READY);  
             ctrl_flag &= (~INSERT_SEG_FULL);   
		    } 
	     } //end of if(insert_seg_full) 

	     //-------œ¬“ª∂Œ◊º±∏∫√ ±Ω¯––’˝≥£◊™Ω”-------------------------------	     
       else if(ctrl_flag & NEXT_SEG_READY) 
	     {
          temp_segment_pointer = interpl_segment_prev;	  //≥Ã–Ú∂Œ◊™Ω”		
          interpl_segment_prev = interpl_segment_curr;    
          interpl_segment_curr = interpl_segment_next;
          interpl_segment_next = temp_segment_pointer;

          ctrl_flag &= ~NEXT_SEG_READY; 
          ctrl_flag |= NEXT_SEG_EMPTY;           
		  mech_status.label = interpl_segment_curr->label; //∏¸–¬∂Œ±Í∫≈
 	     } //end of else if(next_seg_ready) 
       //-----------------------------------------------------------------
       else{;}
      } // end of if(interpl_segment_prev->basecmd == PROGRAM_IDLE)
   } //end of  if((interpl_segment_curr->interp_time[0].term_rem <= blend_term) && (blend_permit))    
  

 //-------------◊‘∂ØÀŸ∂»–ﬁµ˜¥¶¿Ì----------------------------------
 //–ﬁµ˜∂Œ∑≈»Î≤Â»Î∂Œ£¨À˘“‘“™«Ûinterpl_segment_insertŒ™ø’
 if(user_para.speed_scal != mech_status.speed_scal_old)
   {
    if(!(ctrl_flag & INSERT_SEG_FULL))
      { 
	     //if(linear_vel_override(interpl_segment_insert)) //»Áπ˚Ω¯––ÀŸ∂»–ﬁµ˜¥¶¿Ì,–ﬁµ˜∂Œ∑≈»Îinterpl_segment_insert 		   
	       {
	        //ctrl_flag |= INSERT_SEG_FULL;
	       }
      } 
   }   
 
 //-------------◊¥Ã¨ºÏ≤‚¥¶¿Ì-------------------------------------
 switch(mech_status.stat)
   {
    case STA_WORKING:
         if(!(ctrl_flag & TASK_FINISH)) break;
		 if((interpl_segment_prev->basecmd == PROGRAM_IDLE)  //ºÏ≤‚»ŒŒÒÕÍ≥…
               && (interpl_segment_curr->basecmd == PROGRAM_IDLE))          
           {
            mech_status.spindle_rev = 0;
            mech_flag &= ~SPINDLE_ON;
            
            mech_status.stat = STA_FINISHED; 
            ctrl_flag &= (~BEING_AUTO_RUN);                 
			ctrl_flag &= (~BLEND_PERMIT);          
           }
		 break;     
    case STA_PAUSING: //≥–Ω”‘À∂Ø‘›Õ£√¸¡Ó,ºÏ≤‚‘›Õ£ «∑ÒΩ· ¯
         if((interpl_segment_curr->basecmd == PROGRAM_IDLE)   
		       && (interpl_segment_prev->basecmd == PROGRAM_IDLE)) //‘›Õ£ÕÍ≥…
           {
            mech_status.spindle_rev = 0; //÷˜÷·Õ£÷π
            mech_flag &= ~SPINDLE_ON;
            
            mech_status.stat = STA_PAUSED;
           }
         break;

    case STA_STOPPING: //≥–Ω”‘À∂ØÕ£÷π≤Ÿ◊˜,ºÏ≤‚Õ£÷ππ˝≥Ã «∑ÒΩ· ¯
         if((interpl_segment_curr->basecmd == PROGRAM_IDLE)
		          && (interpl_segment_prev->basecmd == PROGRAM_IDLE))
           {
            mech_status.spindle_rev = 0;
            mech_flag &= ~SPINDLE_ON;
           
            mech_status.stat = STA_STOPPED;
            ctrl_flag &= (~BEING_AUTO_RUN);                   
           }
         break;

    case STA_ESTOPPING: //≥–Ω”º±Õ£≤Ÿ◊˜£¨≈–∂œº±Õ£π˝≥Ã «∑ÒΩ· ¯
	     if((interpl_segment_curr->basecmd == PROGRAM_IDLE)
                 && (interpl_segment_prev->basecmd == PROGRAM_IDLE))
           {
		    mech_status.spindle_rev = 0;
            mech_flag &= ~SPINDLE_ON;
            
            mech_status.stat = STA_BROKEN;
            ctrl_flag &= (~BEING_AUTO_RUN);         
           }
		 break;
		 
    case STA_STOPPED:
    case STA_FINISHED:
    case STA_BROKEN:
         mech_flag &= ~USB_COMM_READY;
         if(mech_flag & SIMULATION)
		   { 
		    mech_flag &= ~SIMULATION;
            user_para.speed_scal = speed_scal;  
           } 
         break;
    default:break;
   }  //end of switch 
}  
/********************************************************************************/ 

